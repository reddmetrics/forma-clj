(ns forma.schema
  "A set of functions to structure other queries."
  (:require [forma.date-time :as date]
            [forma.utils :as u]
            [forma.thrift :as thrift]))

(defn create-timeseries
  "Create a TimeSeries from a period start index and a collection of timeseries
   values. The period end index is calculated by adding the size of the
   collection to the period start index."
  ([start-idx series]
     {:pre [(> start-idx 0) (coll? series)]}
     (when series
       (let [elems (count series)]
         (create-timeseries start-idx (dec (+ start-idx elems)) series))))
  ([start-idx end-idx series]
     {:pre [(> start-idx 0) (<= start-idx end-idx) (coll? series)]}
     (when series
       (thrift/TimeSeries* start-idx end-idx series))))

(defn boundaries
  "Accepts a sequence of pairs of <initial time period, collection>
  and returns the maximum start period and the minimum end period.

  Example usage:
    (boundaries [0 [1 2 3 4] 1 [2 3 4 5]]) => [1 4]"
  [pair-seq]
  {:pre [(even? (count pair-seq))]}
  (reduce (fn [[lo hi] [x0 ct]]
            [(max lo x0) (min hi ct)])
          (for [[x0 seq] (partition 2 pair-seq)]
            [x0 (+ x0 (count seq))])))

(defn adjust
  "Appropriately truncates the incoming timeseries values (paired with
  the initial integer period), and outputs a new start and both
  truncated series.

  Example usage:
    (adjust 0 [1 2 3 4] 1 [2 3 4 5]) => (1 [2 3 4] [2 3 4])"
  [& pairs]
  {:pre [(even? (count pairs))]}
  (let [[bottom top] (boundaries pairs)]
    (cons bottom
          (for [[x0 seq] (partition 2 pairs)]
            (into [] (u/trim-seq bottom top x0 seq))))))

(defn adjust-fires
  "Returns a TimeSeries object of fires that are within the bounds of
  the interval defined by :est-start, :est-end, and :t-res.  Within
  the FORMA workflow, this function is applied to a series of
  FireValues that is longer (on the tail-end or both the tail- and
  front-end) of the interval based on the info in the estimation
  parameter map.  This series may not have any actual fire hits in it;
  but rather is a vector of zero-value fires -- a sort of sparse
  vector where each element is a FireValue.

  TODO: preconditions to test that the supplied series matches the
  description above.  Then adjust the description to be shorter, more
  understandable."
  [est-start est-end t-res f-series]
  {:pre [(let [fire-start-pd (first (thrift/unpack f-series))
               est-start-pd (date/datetime->period t-res est-start)]
           (<= fire-start-pd est-start-pd))]}
  (let [[f-start f-end arr-val] (thrift/unpack f-series)
        series (thrift/unpack arr-val)
        [start end] (map (partial date/datetime->period t-res)
                         [est-start est-end])]
    [(->> series
          (u/trim-seq start (inc end) f-start)
          (thrift/TimeSeries* start))]))

(defn adjust-fires-simple
  [start-idx model-series fire-series]
  (if (nil? fire-series)
    fire-series
    (let [[f-start f-end arr-val] (thrift/unpack fire-series)
          series (thrift/unpack arr-val)
          [start _ fires] (adjust start-idx model-series f-start series)]
      (thrift/TimeSeries* start fires))))

(defn add-fires
  "Returns a new `FireValue` object generated by summing up the fields
  of each of the supplied `FireValue` objects."
  [& f-tuples]
  (->> f-tuples
       (map thrift/unpack)
       (apply map +)
       (apply thrift/FireValue*)))

(defn neighbor-value
  "Accepts either a forma value or a sequence of sub-values."
  ([forma-val]
     (let [[fire short long t-stat break] (thrift/unpack forma-val)]
       (thrift/NeighborValue* fire 1 short short long long t-stat t-stat break break)))
  ([fire neighbors avg-short
    min-short avg-long min-long avg-stat min-stat avg-break max-break]
     (thrift/NeighborValue* fire neighbors avg-short min-short avg-long min-long
                            avg-stat min-stat avg-break max-break)))

(def empty-neighbor-val
  "Returns a NeighborValue object with values for a pixel that should
  have an empty or nil value without breaking the process.  TODO:
  figure out what values should be inserted for each feature to truly
  represent the notion of emptiness."
  (thrift/NeighborValue* (thrift/FireValue* 0 0 0 0)
                         (long 0) 0. 0. 0. 0. 0. 0. 0. 0.))

(defn merge-neighbors
  "Merges the supplied instance of `FormaValue` into the existing
  aggregate collection of `FormaValue`s represented by `neighbor-val`.
  Returns a new neighbor value object representing the merged values."
  [nodata neighbor-val forma-val]
  {:pre [(instance? forma.schema.NeighborValue neighbor-val)]}
  (cond
   (and (thrift/obj-contains-nodata? nodata neighbor-val)
        (thrift/obj-contains-nodata? nodata forma-val))
              empty-neighbor-val
   (thrift/obj-contains-nodata? nodata neighbor-val)
              (neighbor-value forma-val)
   (thrift/obj-contains-nodata? nodata forma-val)
              neighbor-val
   :else (let [[fire short-val long-val t-stat break] (thrift/unpack forma-val)
               [n-fire ncount avg-short min-short avg-long
                min-long avg-stat min-stat avg-break max-break] (thrift/unpack neighbor-val)]
           (thrift/NeighborValue* (add-fires n-fire fire)
                                  (inc ncount)
                                  (u/weighted-mean avg-short ncount short-val 1)
                                  (min min-short short-val)
                                  (u/weighted-mean avg-long ncount long-val 1)
                                  (min min-long long-val)
                                  (u/weighted-mean avg-stat ncount t-stat 1)
                                  (min min-stat t-stat)
                                  (u/weighted-mean avg-break ncount break 1)
                                  (max max-break break)))))

(defn combine-neighbors
  "Returns a new forma neighbor value generated by merging together
   each entry in the supplied sequence of forma values.  See tests for
   example usage."
  [nodata [x & more]]
  (if x
    (reduce (partial merge-neighbors nodata) (neighbor-value x) more)
    empty-neighbor-val))

(defn forma-value
  "Returns a `FormaValue`, given a `FireValue` (or `nil`), short stat,
   long stat, t-stat and break stat. Exists to handle the case where
   there are no fires in a given pixel. A `nil` value would normally
   cause an exception to be thrown by `thrift/FormaValue*`"
  [fire short long t-stat param-break]
  (let [fire (or fire
                 (thrift/FireValue* 0 0 0 0))]
    (thrift/FormaValue* fire short long t-stat param-break)))

(defn fires-cleanup
  "If the fire-series is nil, leave it be, else, unpack it. fire-series
   is a TimeSeries object"
  [fire-series]
  (if (nil? fire-series)
    fire-series
    (thrift/unpack (thrift/get-series fire-series))))

(defn cleanup-shorts
  "Cleanup break series: replace nil with value from left or
  `big-val` so that `reductions min` doesn't trip over `nil`
  values. Then replace any remaining `big-val` with `nodata."
  [short-series nodata big-val]
  (->> (u/replace-from-left nil short-series :default big-val)
       (reductions min)
       vec
       (u/replace-all big-val nodata)))

(defn cleanup-breaks
  "Cleanup break series: replace nil with value from left or
  `small-val` so that `reductions max` doesn't trip over `nil`
  values. Then replace any remaining `small-val` with `nodata."
  [break-series nodata small-val]
  (->> (u/replace-from-left nil break-series :default small-val)
       vec
       (reductions max)
       (u/replace-all small-val nodata)))

(defn forma-seq-prep
  "Prepare data for creating sequence of `FormaValues`, replacing
  `nil` values with `nodata` values. Given the use of `min` and `max`
  for some series, `nils` are handled appropriately so that the
  `nodata` value does not appear needlessly in the series used to
  create `FormaValues`."
  [nodata fire-series short-series long-series t-stat-series break-series]
  (let [fires (fires-cleanup fire-series)
        big-val 1000000
        small-val -1000000
        shorts (cleanup-shorts short-series nodata big-val)
        longs (u/replace-all nil nodata long-series)
        t-stats (u/replace-all nil nodata t-stat-series)
        breaks (cleanup-breaks break-series nodata small-val)]
    [fires shorts longs t-stats breaks]))

(defn series->forma-values
  "Given vectors of equal length of fires and trends stats, create vector
   of FormaValues. This vector can be used to produce a TimeSeries object."
  [fires shorts longs t-stats breaks]
  [(->> (concat [fires] [shorts] [longs] [t-stats] [breaks])
        (map #(or % (repeat %)))
        (apply map forma-value)
        (vec))])

(defn forma-seq
  "Accepts 5 timeseries of equal length and starting position, each
   representing a time-indexed series of features for a given pixel.
   Returns the tranposition: a single timeseries of
   FormaValues.

  `fire-series` gets special treatment because it could come into
   `forma-seq` as nil (i.e. no fires for a given pixel) per the
   forma-tap query in forma.clj; fires is an ungrounded variable in
   the cascalog query, forma-tap"
  [nodata fire-series short-series long-series t-stat-series break-series]
  (let [[fires
         shorts
         longs
         t-stats
         breaks] (forma-seq-prep nodata fire-series short-series
                                 long-series t-stat-series
                                 break-series)]
    (series->forma-values fires shorts longs t-stats breaks)))
